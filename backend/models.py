# This file will contain the MongoDB data models (schemas)
# We will use Pydantic or Marshmallow for schema validation later, if desired,
# or just work with dictionaries directly with PyMongo.

# Example (will be expanded later):
# class User:
#     def __init__(self, username, password_hash, role, email):
#         self.username = username
#         self.password_hash = password_hash
#         self.role = role # 'student', 'teacher', 'admin'
#         self.email = email

# class Course:
#     def __init__(self, course_code, course_name, teacher_id, description):
#         self.course_code = course_code
#         self.course_name = course_name
#         self.teacher_id = teacher_id # ObjectId of the teacher
#         self.description = description
#         self.students_enrolled = [] # List of student_ids
#         self.assignments = [] # List of assignment dicts/ids
#         self.quizzes = [] # List of quiz dicts/ids
#         self.feedback = [] # List of feedback dicts

# We'll define these more formally as we build out the features. 

# --- User Collection --- (mongo.db.users)
# {
#     "_id": ObjectId(),            # Auto-generated by MongoDB
#     "username": "string",         # Unique, indexed
#     "email": "string",            # Unique, indexed
#     "password_hash": "string",
#     "role": "string",             # 'student', 'teacher', or 'admin', indexed
#     "first_name": "string",       # Optional
#     "last_name": "string",        # Optional
#     "date_joined": "datetime",    # Timestamp of registration
#     "is_active": "boolean",       # For soft deletes or deactivation
#     "last_login": "datetime",     # Optional
#     # Student-specific fields (if role is 'student')
#     "student_id_str": "string",   # University-assigned student ID, if any
#     "enrolled_courses": [ObjectId(), ...], # References Course._id
#     "major": "string",            # Optional
#     # Teacher-specific fields (if role is 'teacher')
#     "teacher_id_str": "string",   # University-assigned teacher ID, if any
#     "courses_teaching": [ObjectId(), ...], # References Course._id
#     "department": "string",       # Optional
# }

# --- Course Collection --- (mongo.db.courses)
# {
#     "_id": ObjectId(),            # Auto-generated by MongoDB
#     "course_code": "string",      # e.g., "CS101", Unique, indexed
#     "course_name": "string",
#     "description": "string",
#     "teacher_id": ObjectId(),     # References User._id (must be a user with 'teacher' role), indexed
#     "credits": "integer",
#     "department": "string",       # e.g., "Computer Science"
#     "max_capacity": "integer",
#     "current_enrollment": "integer", # Default 0, updated on student enrollment/drop
#     "semester": "string",         # e.g., "Fall 2024"
#     "year": "integer",
#     "schedule_info": "string",    # e.g., "Mon, Wed, Fri 10:00-11:00 AM, Room 302"
#     "assignments": [ObjectId(), ...], # References Assignment._id (to be defined)
#     "quizzes": [ObjectId(), ...],     # References Quiz._id (to be defined)
#     "feedback": [
#         {
#             "student_id": ObjectId(),
#             "rating": "integer", # e.g., 1-5
#             "comment": "string",
#             "date_posted": "datetime"
#         }
#     ]
# }

# --- Enrollment Collection --- (mongo.db.enrollments) - To manage student-course relationships
# This collection helps manage many-to-many relationships and can store enrollment-specific data.
# {
#     "_id": ObjectId(),
#     "student_id": ObjectId(), # References User._id (student)
#     "course_id": ObjectId(),  # References Course._id
#     "enrollment_date": "datetime",
#     "grade": "string",        # Final grade for the course (e.g., "A", "B+") - updated later
#     "status": "string",       # e.g., "enrolled", "dropped", "completed"
#     # This creates a unique constraint on student_id and course_id
#     # db.enrollments.createIndex( { "student_id": 1, "course_id": 1 }, { "unique": true } )
# }


# --- Other potential collections to be defined later ---
# - Assignments
# - Quizzes
# - Submissions (for assignments/quizzes)
# - Grades (detailed breakdown: quiz1, assignment1, final_exam)
# - Attendance
# - Notifications
# - Transactions (for pessimistic/optimistic locking, if using a separate collection for logs) 

from pydantic import BaseModel, Field, EmailStr, validator
from typing import List, Optional, Dict, Any
from datetime import datetime, date
from bson import ObjectId
from enum import Enum

# Custom ObjectId field for Pydantic
class PyObjectId(ObjectId):
    @classmethod
    def __get_validators__(cls):
        yield cls.validate

    @classmethod
    def validate(cls, v):
        if not ObjectId.is_valid(v):
            raise ValueError("Invalid ObjectId")
        return ObjectId(v)

    @classmethod
    def __modify_schema__(cls, field_schema):
        field_schema.update(type="string")

class UserRole(str, Enum):
    STUDENT = "student"
    TEACHER = "teacher"
    ADMIN = "admin"

class EnrollmentStatus(str, Enum):
    ENROLLED = "enrolled"
    DROPPED = "dropped"
    COMPLETED = "completed"
    WAITLISTED = "waitlisted"

class AssignmentType(str, Enum):
    HOMEWORK = "homework"
    PROJECT = "project"
    LAB = "lab"
    ESSAY = "essay"

class QuizType(str, Enum):
    MULTIPLE_CHOICE = "multiple_choice"
    SHORT_ANSWER = "short_answer"
    ESSAY = "essay"
    PRACTICAL = "practical"

class SubmissionStatus(str, Enum):
    SUBMITTED = "submitted"
    LATE = "late"
    GRADED = "graded"
    PENDING = "pending"

# === USER MODELS ===
class UserBase(BaseModel):
    username: str = Field(..., min_length=3, max_length=50)
    email: EmailStr
    first_name: Optional[str] = Field(None, max_length=50)
    last_name: Optional[str] = Field(None, max_length=50)
    role: UserRole
    is_active: bool = True
    date_joined: datetime = Field(default_factory=datetime.utcnow)
    last_login: Optional[datetime] = None

class UserCreate(UserBase):
    password: str = Field(..., min_length=8)

class UserInDB(UserBase):
    id: PyObjectId = Field(default_factory=PyObjectId, alias="_id")
    password_hash: str
    student_id_str: Optional[str] = None
    teacher_id_str: Optional[str] = None
    major: Optional[str] = None
    department: Optional[str] = None
    enrolled_courses: List[PyObjectId] = []
    courses_teaching: List[PyObjectId] = []

    class Config:
        allow_population_by_field_name = True
        arbitrary_types_allowed = True
        json_encoders = {ObjectId: str}

# === COURSE MODELS ===
class CourseFeedback(BaseModel):
    student_id: PyObjectId
    rating: int = Field(..., ge=1, le=5)
    comment: Optional[str] = None
    date_posted: datetime = Field(default_factory=datetime.utcnow)

class CourseBase(BaseModel):
    course_code: str = Field(..., max_length=20)
    course_name: str = Field(..., max_length=200)
    description: Optional[str] = None
    credits: int = Field(..., ge=1, le=10)
    department: str = Field(..., max_length=100)
    max_capacity: int = Field(..., ge=1)
    semester: str = Field(..., max_length=20)
    year: int = Field(..., ge=2020, le=2040)
    schedule_info: Optional[str] = None

class CourseCreate(CourseBase):
    teacher_id: Optional[PyObjectId] = None

class CourseInDB(CourseBase):
    id: PyObjectId = Field(default_factory=PyObjectId, alias="_id")
    teacher_id: Optional[PyObjectId] = None
    current_enrollment: int = 0
    assignments: List[PyObjectId] = []
    quizzes: List[PyObjectId] = []
    feedback: List[CourseFeedback] = []
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

    class Config:
        allow_population_by_field_name = True
        arbitrary_types_allowed = True
        json_encoders = {ObjectId: str}

# === ENROLLMENT MODELS ===
class EnrollmentBase(BaseModel):
    student_id: PyObjectId
    course_id: PyObjectId
    enrollment_date: datetime = Field(default_factory=datetime.utcnow)
    status: EnrollmentStatus = EnrollmentStatus.ENROLLED
    grade: Optional[str] = None

class EnrollmentInDB(EnrollmentBase):
    id: PyObjectId = Field(default_factory=PyObjectId, alias="_id")
    drop_date: Optional[datetime] = None
    completion_date: Optional[datetime] = None

    class Config:
        allow_population_by_field_name = True
        arbitrary_types_allowed = True
        json_encoders = {ObjectId: str}

# === ASSIGNMENT MODELS ===
class AssignmentBase(BaseModel):
    title: str = Field(..., max_length=200)
    description: Optional[str] = None
    assignment_type: AssignmentType
    total_points: int = Field(..., ge=1)
    due_date: datetime
    created_date: datetime = Field(default_factory=datetime.utcnow)
    instructions: Optional[str] = None
    attachments: List[str] = []  # File paths/URLs

class AssignmentCreate(AssignmentBase):
    course_id: PyObjectId

class AssignmentInDB(AssignmentBase):
    id: PyObjectId = Field(default_factory=PyObjectId, alias="_id")
    course_id: PyObjectId
    teacher_id: PyObjectId
    is_published: bool = True
    submissions: List[PyObjectId] = []

    class Config:
        allow_population_by_field_name = True
        arbitrary_types_allowed = True
        json_encoders = {ObjectId: str}

# === QUIZ MODELS ===
class QuizQuestion(BaseModel):
    question_text: str
    question_type: str  # "multiple_choice", "short_answer", "essay"
    options: Optional[List[str]] = None  # For multiple choice
    correct_answer: Optional[str] = None
    points: int = Field(..., ge=1)

class QuizBase(BaseModel):
    title: str = Field(..., max_length=200)
    description: Optional[str] = None
    quiz_type: QuizType
    total_points: int = Field(..., ge=1)
    time_limit: Optional[int] = None  # Minutes
    due_date: datetime
    start_date: datetime
    questions: List[QuizQuestion] = []

class QuizCreate(QuizBase):
    course_id: PyObjectId

class QuizInDB(QuizBase):
    id: PyObjectId = Field(default_factory=PyObjectId, alias="_id")
    course_id: PyObjectId
    teacher_id: PyObjectId
    is_published: bool = True
    submissions: List[PyObjectId] = []
    created_date: datetime = Field(default_factory=datetime.utcnow)

    class Config:
        allow_population_by_field_name = True
        arbitrary_types_allowed = True
        json_encoders = {ObjectId: str}

# === SUBMISSION MODELS ===
class SubmissionBase(BaseModel):
    student_id: PyObjectId
    submission_date: datetime = Field(default_factory=datetime.utcnow)
    content: Optional[str] = None  # Text content
    attachments: List[str] = []  # File paths/URLs
    status: SubmissionStatus = SubmissionStatus.SUBMITTED

class AssignmentSubmissionInDB(SubmissionBase):
    id: PyObjectId = Field(default_factory=PyObjectId, alias="_id")
    assignment_id: PyObjectId
    score: Optional[float] = None
    feedback: Optional[str] = None
    graded_date: Optional[datetime] = None
    graded_by: Optional[PyObjectId] = None

    class Config:
        allow_population_by_field_name = True
        arbitrary_types_allowed = True
        json_encoders = {ObjectId: str}

class QuizSubmissionAnswer(BaseModel):
    question_index: int
    answer: str
    is_correct: Optional[bool] = None
    points_earned: Optional[float] = None

class QuizSubmissionInDB(SubmissionBase):
    id: PyObjectId = Field(default_factory=PyObjectId, alias="_id")
    quiz_id: PyObjectId
    answers: List[QuizSubmissionAnswer] = []
    total_score: Optional[float] = None
    time_taken: Optional[int] = None  # Minutes
    graded_date: Optional[datetime] = None
    graded_by: Optional[PyObjectId] = None

    class Config:
        allow_population_by_field_name = True
        arbitrary_types_allowed = True
        json_encoders = {ObjectId: str}

# === ATTENDANCE MODELS ===
class AttendanceRecord(BaseModel):
    id: PyObjectId = Field(default_factory=PyObjectId, alias="_id")
    course_id: PyObjectId
    date: date
    student_attendances: Dict[str, bool] = {}  # student_id -> present/absent
    recorded_by: PyObjectId  # teacher_id
    recorded_at: datetime = Field(default_factory=datetime.utcnow)

    class Config:
        allow_population_by_field_name = True
        arbitrary_types_allowed = True
        json_encoders = {ObjectId: str}

# === GRADE MODELS ===
class GradeComponent(BaseModel):
    component_type: str  # "assignment", "quiz", "exam", "participation"
    component_id: Optional[PyObjectId] = None
    name: str
    points_earned: float
    total_points: float
    weight: float = 1.0  # Weight in final grade calculation

class StudentGrade(BaseModel):
    id: PyObjectId = Field(default_factory=PyObjectId, alias="_id")
    student_id: PyObjectId
    course_id: PyObjectId
    components: List[GradeComponent] = []
    final_grade: Optional[str] = None  # Letter grade
    final_percentage: Optional[float] = None
    calculated_at: Optional[datetime] = None

    class Config:
        allow_population_by_field_name = True
        arbitrary_types_allowed = True
        json_encoders = {ObjectId: str}

# === CALENDAR/EVENT MODELS ===
class CalendarEvent(BaseModel):
    id: PyObjectId = Field(default_factory=PyObjectId, alias="_id")
    title: str
    description: Optional[str] = None
    event_type: str  # "assignment", "quiz", "exam", "class", "deadline"
    course_id: Optional[PyObjectId] = None
    start_datetime: datetime
    end_datetime: Optional[datetime] = None
    created_by: PyObjectId
    attendees: List[PyObjectId] = []  # student_ids or teacher_ids
    created_at: datetime = Field(default_factory=datetime.utcnow)

    class Config:
        allow_population_by_field_name = True
        arbitrary_types_allowed = True
        json_encoders = {ObjectId: str}

# === NOTIFICATION MODELS ===
class NotificationBase(BaseModel):
    recipient_id: PyObjectId
    title: str
    message: str
    notification_type: str  # "assignment", "grade", "enrollment", "announcement"
    related_course_id: Optional[PyObjectId] = None
    related_assignment_id: Optional[PyObjectId] = None
    is_read: bool = False

class NotificationInDB(NotificationBase):
    id: PyObjectId = Field(default_factory=PyObjectId, alias="_id")
    created_at: datetime = Field(default_factory=datetime.utcnow)
    read_at: Optional[datetime] = None

    class Config:
        allow_population_by_field_name = True
        arbitrary_types_allowed = True
        json_encoders = {ObjectId: str} 